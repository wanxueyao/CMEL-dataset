{
  "chunk-9705c1be981fe537fcfa695340dc636a": {
    "tokens": 1200,
    "content": "# What makes a good conversation? How controllable attributes affect human judgments  \n\nAbigail See∗ Stephen Roller Douwe Kiela Jason Weston Stanford University Facebook AI Research Facebook AI Research Facebook AI Research abisee@stanford.edu roller@fb.com dkiela@fb.com jase@fb.com  \n\n# Abstract  \n\nA good conversation requires balance – between simplicity and detail; staying on topic and changing it; asking questions and answering them. Although dialogue agents are commonly evaluated via human judgments of overall quality, the relationship between quality and these individual factors is less well-studied. In this work, we examine two controllable neural text generation methods, conditional training and weighted decoding, in order to control four important attributes for chitchat dialogue: repetition, specificity, response-relatedness and question-asking. We conduct a large-scale human evaluation to measure the effect of these control parameters on multi-turn interactive conversations on the PersonaChat task. We provide a detailed analysis of their relationship to high-level aspects of conversation, and show that by controlling combinations of these variables our models obtain clear improvements in human quality judgments.  \n\n# 1 Introduction  \n\nNeural generation models for dialogue, despite their ubiquity in current research, are still poorly understood. Well known problems, such as the genericness and repetitiveness of responses (Serban et al., 2016a), remain without a de facto solution. Strikingly, the factors that determine human judgments of overall conversation quality are almost entirely unexplored. Most works have been limited to the next utterance prediction problem, whereas a multi-turn evaluation is necessary to evaluate the quality of a full conversation.  \n\nIn this work we both (i) conduct a large-scale study to identify the fine-grained factors governing human judgments of full conversations, and (ii) develop models that apply our findings in practice, Figure 1: We manipulate four low-level attributes and measure their effect on human judgments of individual conversational aspects, as well as overall quality.  \n\n![](images/image_1.jpg)  \n\nleading to state-of-the-art performance. Specifi- cally, we identify and study eight aspects of conversation that can be measured by human judgments, while varying four types of low-level attributes that can be algorithmically controlled in neural models; see Figure 1. To control the lowlevel model attributes, we consider two simple but general algorithms: conditional training, in which the neural model is conditioned on additional control features, and weighted decoding, in which control features are added to the decoding scoring function at test time only.  \n\nOne major result of our findings is that existing work has ignored the importance of conversational flow, as standard models (i) repeat or contradict previous statements, (ii) fail to balance specificity with genericness, and (iii) fail to balance asking questions with other dialogue acts. Conducting experiments on the PersonaChat task (Zhang et al., 2018b), we obtain significantly higher engagingness scores than the baseline by optimizing control of repetition, specificity and question-asking over multiple turns. Using these findings, our best model matches the performance of the winning entry in the recent NeurIPS ConvAI2 competition (Dinan et al., 2019), which was trained on much more data but had no control (see Section 8.1). Our code, pretrained models, and full chatlogs, are available at https://parl.ai/projects/ controllable_dialogue.  \n\n# 2 Related Work  \n\nDialogue Dialogue evaluation is relatively well understood in goal-oriented tasks, where automated approaches can be coded by measuring task completion (Bordes et al., 2017; El Asri et al., 2017; Hastie, 2012; Henderson et al., 2014; Wen et al., 2017). Task success combined with dialogue cost can be linked to human judgments like user satisfaction via the PARADISE framework (Walker et al., 1997).  \n\nHowever in chitchat tasks, which we study in this work, automatic metrics and their relation to human ratings are less well-understood. While word-overlap metrics are effective for questionanswering and machine translation, for dialogue they have little to no correlation with human judgments (Liu et al., 2016; Novikova et al., 2017) – this is due to the open-ended nature of dialogue. There are more recent attempts to find better automatic approaches, such as adversarial evaluation (Li et al., 2017b) and learning a scoring model (Lowe et al., 2017), but their value is still unclear. Nevertheless, a number of studies only use automatic metrics, with no human study at all (Lowe et al., 2015; Parthasarathi and Pineau, 2018; Serban et al., 2016b). Other works do use human evaluations (Dinan et al., 2018; Li et al., 2016a,b; Venkatesh et al., 2017; Vinyals and Le, 2015; Zhang et al., 2018b), typically reporting just one type of judgment (either quality or appropriateness) via a Likert scale or pairwise comparison. Most of those works only consider single turn evaluations, often with a shortened dialogue history, rather than full multi-turn dialogue.  \n\nA more comprehensive evaluation strategy has been studied within the scope of the Alexa prize (Venkatesh et al., 2017; Guo et al., 2018) by combining multiple automatic metrics designed to capture various conversational aspects (engagement, coherence, domain coverage, conversational depth and topical diversity). Though these aspects have some similarity to the aspects studied here, we also focus on lower-level aspects (e.g. avoiding repetition, fluency), to understand how they correspond to both our controllable attributes, and to overall quality judgments.  \n\nControllable neural text generation Researchers have",
    "chunk_order_index": 0,
    "full_doc_id": "doc-918c69166fc1f4976fcf7ccbb9757946"
  },
  "chunk-bf66f6f22e5b9575c46238ccab2836a8": {
    "tokens": 1200,
    "content": "enkatesh et al., 2017; Guo et al., 2018) by combining multiple automatic metrics designed to capture various conversational aspects (engagement, coherence, domain coverage, conversational depth and topical diversity). Though these aspects have some similarity to the aspects studied here, we also focus on lower-level aspects (e.g. avoiding repetition, fluency), to understand how they correspond to both our controllable attributes, and to overall quality judgments.  \n\nControllable neural text generation Researchers have proposed several approaches to control aspects of RNN-based natural language generation such as sentiment, length, speaker style and tense (Fan et al., 2018; Ficler and Goldberg, 2017; Ghazvininejad et al., 2017; Hu et al., 2017; Kikuchi et al., 2016; Peng et al., 2018; Wang et al., 2017). In particular, several works use control to tackle the same common sequence-to-sequence problems we address here (particularly genericness and unrelated output), in the context of single-turn response generation (Baheti et al., 2018; Li et al., 2016a, 2017a; Shen et al., 2017; Xing et al., 2017; Zhang et al., 2018a; Zhou et al., 2017). By contrast, we focus on developing controls for, and human evaluation of, multi-turn interactive dialogue – this includes a new method (described in Section 5) to control attributes at the dialogue level rather than the utterance level.  \n\nIn this work, we require a control method that is both general-purpose (one technique to simultaneously control many attributes) and easily tunable (the control setting is adjustable after training). Given these constraints, we study two control methods: conditional training (variants of which have been described by Fan et al. (2018); Kikuchi et al. (2016); Peng et al. (2018)) and weighted decoding (described by Ghazvininejad et al. (2017) as a general technique, and by Baheti et al. (2018) to control response-relatedness). To our knowledge, this work is the first to systematically compare the effectiveness of two general-purpose control methods across several attributes.  \n\n# 3 The PersonaChat dataset  \n\nPersonaChat (Zhang et al., 2018b) is a chitchat dialogue task involving two participants (two humans or a human and a bot). Each participant is given a persona – a short collection of personal traits such as I’m left handed or My favorite season is spring – and are instructed to get to know each other by chatting naturally using their designated personas, for 6–8 turns. The training set contains 8939 conversations and 955 personas, collected via crowdworkers, plus 1000 conversations and 100 personas for validation, and a similar number in the hidden test set. The PersonaChat task was the subject of the NeurIPS 2018 ConvAI2 Challenge (Dinan et al., 2019), in which competitors were first evaluated with respect to automatic metrics (perplexity, hits $@1$ and F1 score), and then with respect to human judgment via the question “How much did you enjoy talking to this user?” on a scale of 1–4.  \n\n# 4 Baseline model  \n\nOur baseline model is a 2-layer LSTM sequenceto-sequence model with attention. On any dialogue turn, the input $x$ to the encoder is the entire dialogue history (separated using unique speakeridentifying tokens), with the model’s own persona prepended. Conditioned on this input sequence $x$ , the decoder generates a response $y$ . Except when stated otherwise, all our models decode using beam search with beam size 20.  \n\nWe initialized the word embedding matrix with 300-dimensional GloVe embeddings (Pennington et al., 2014). Using the ParlAI framework (Miller et al., 2017), we pretrained the model on a dataset of 2.5 million Twitter message-response pairs,1 then fine-tuned it on PersonaChat. On the PersonaChat validation set, the baseline model has a perplexity of 26.83 and F1 of 17.02, which would have placed us 4th out of 26 models in the ConvAI2 competition (Dinan et al., 2019). We attempt to improve over this baseline using control.  \n\n# 5 Controllable text generation methods  \n\nSuppose we have a sequence-to-sequence model which gives $P(y|x)\\;=\\;\\Pi_{t}P(y_{t}|x,y_{1},\\ldots,y_{t-1}),$ ,the conditional probability of a response $y$ (the model’s next utterance) given input $x$ (the context, which in our case includes the model’s own persona and the dialogue history).  \n\nContrary to most previous work, which controls at the sentence level, we wish to control attributes of the output $y$ at the dialogue level – meaning that a single control setting is used for a whole dialogue. For example, to control questionasking, we provide a control setting at the beginning of each dialogue (e.g. $20\\%$ questions or $70\\%$ questions) rather than providing a control setting for each utterance (e.g. is a question or isn’t $a$ question). With this approach, the sequence-tosequence model is able to choose what value the controlled attribute should take for any particular utterance, but we are able to choose the overall distribution. We find that this approach works well – for example, the sequence-to-sequence model is generally good at detecting when to ask a question. In particular, this",
    "chunk_order_index": 1,
    "full_doc_id": "doc-918c69166fc1f4976fcf7ccbb9757946"
  },
  "chunk-01da31c71e06892fb52b24a57d9339ad": {
    "tokens": 1200,
    "content": "70\\%$ questions) rather than providing a control setting for each utterance (e.g. is a question or isn’t $a$ question). With this approach, the sequence-tosequence model is able to choose what value the controlled attribute should take for any particular utterance, but we are able to choose the overall distribution. We find that this approach works well – for example, the sequence-to-sequence model is generally good at detecting when to ask a question. In particular, this is easier than the alternative: developing a separate process to decide, for each utterance, whether to ask a question.  \n\nIn this section, we describe the two methods – which we call Conditional Training (CT) and Weighted Decoding (WD) – that we use to control attributes of the output $y$ at the dialogue level.  \n\n# 5.1 Conditional Training (CT)  \n\nConditional Training (Fan et al., 2018; Kikuchi et al., 2016; Peng et al., 2018) is a method to learn a sequence-to-sequence model $P(y|x,z)$ ,where $z$ is a discrete control variable. If the control attribute is naturally continuous (for example in our work, repetitiveness, specificity and response-relatedness), we use $z$ to represent bucketed ranges. For a binary attribute like questionasking, $z$ represents an overall probability (as explained in Section 5).  \n\nTo train a CT model, we first automatically annotate every $(x,y)$ pair in the training set with the attribute we wish to control (for example, whether $y$ contains a question mark). During training, for each example we determine the corresponding $z$ value (for continuous attributes, this simply means sorting into the correct bucket; for question-asking, see Section 6.4). Next, the control variable $z$ is represented via an embedding (each of the possible values of $z$ has its own embedding). For all our experiments, the embedding is of length 10; this was determined via hyperparameter tuning. There are several possible ways to condition the sequence-to-sequence model on $z$ – for example, append $z$ to the end of the input sequence, or use $z$ as the START symbol for the decoder. We find it most effective to concatenate $z$ to the decoder’s input on every step. Lastly, the CT model learns to produce $y\\;=\\;y_{1},\\ldots,y_{T}$ by optimizing the cross-entropy loss:  \n\n$$\n\\mathrm{loss_{CT}}=-\\frac{1}{T}\\sum_{t=1}^{T}\\log P(y_{t}|x,z,y_{1},\\ldots,y_{t-1})\n$$  \n\nOur CT models are initialized with the parameters from the baseline sequence-to-sequence model $P(\\boldsymbol{y}|\\boldsymbol{x})$ (the new decoder parameters are initialized with small random values), then fine-tuned to optimize $\\mathrm{loss}_{\\mathrm{CT}}$ on the PersonaChat training set, until convergence of lossCT on the validation set.  \n\n# 5.2 Weighted Decoding (WD)  \n\nWeighted Decoding (Ghazvininejad et al., 2017) is a decoding method that increases or decreases the probability of words with certain features. The technique is applied only at test time, requiring no change to the training method. A limitation of WD is that the controllable attribute must be defined at the word-level; any desired utterance-level attribute must be redefined via word-level features.  \n\nIn weighted decoding, on the $t^{t h}$ step of decoding, a partial hypothesis $y_{<t}=y_{1},...\\,,y_{t-1}$ is expanded by computing the score for each possible next word $w$ in the vocabulary:  \n\n$$\n\\begin{array}{l}{\\displaystyle\\mathrm{score}(w,y_{<t};x)=\\mathrm{score}(y_{<t};x)\\medskip}\\\\ {\\displaystyle\\,+\\log P_{\\mathrm{RNN}}(w|y_{<t},x)+\\sum_{i}w_{i}*f_{i}(w;y_{<t},x).}\\end{array}\n$$  \n\nHere, $\\log P_{\\mathrm{RNN}}(w|y_{<t},x)$ is the log-probability of the word $w$ calculated by the RNN, score $(y{<}t;x)$ is the accumulated score of the already-generated words in the hypothesis $y{<}t$ , and $f_{i}(w;y{<}t,x)$ are decoding features with associated weights $w_{i}$ .There can be multiple features $f_{i}$ (to control multiple attributes), and the weights $w_{i}$ are hyperparameters to be chosen.  \n\nA decoding feature $f_{i}(w;y_{<t},x)$ assigns a real value to the word $w$ , in the context of the text generated so far $y{<}t$ and the context $x$ . The feature can be continuous (e.g. the unigram probability of $w_{\\ast}$ ), discrete (e.g. the length of $w$ in characters), or binary (e.g. whether $w$ starts with the same letter as the last word in $y_{<t}$ ). A positive weight $w_{i}$ increases the probability of words $w$ that score highly with respect to $f_{i}$ ; a negative weight decreases their probability.  \n\nNote that weighted decoding and conditional training can be applied simultaneously (i.e. train a CT model then apply WD at test time) – a strategy we use in our experiments.",
    "chunk_order_index": 2,
    "full_doc_id": "doc-918c69166fc1f4976fcf7ccbb9757946"
  },
  "chunk-b6fc9ca9b139955a3cf8698c53a63d18": {
    "tokens": 1200,
    "content": "), or binary (e.g. whether $w$ starts with the same letter as the last word in $y_{<t}$ ). A positive weight $w_{i}$ increases the probability of words $w$ that score highly with respect to $f_{i}$ ; a negative weight decreases their probability.  \n\nNote that weighted decoding and conditional training can be applied simultaneously (i.e. train a CT model then apply WD at test time) – a strategy we use in our experiments.  \n\n# 6 Controlling conversational attributes  \n\nIn this section, we describe how we use conditional training and weighted decoding to control four attributes: repetition, specificity, responserelatedness and question-asking. We evaluate the effectiveness of both control methods via automatic metrics (i.e., measuring how well the attribute was controlled), and use our findings to select control methods and control settings to be explored further via human evaluation (Section 8).  \n\n# 6.1 Repetition  \n\nOur baseline model exhibits three types of repetition, which we call external repetition (selfrepetition across utterances), internal repetition (self-repetition within utterances), and partner repetition (repeating the conversational partner).  \n\nTo control repetition with weighted decoding,3 we define five $n$ -gram based decoding features (see Appendix D). Three of these features (extrep bigram, intrep bigram and partnerrep bigram) identify repeating bigrams for the three repetition types. The other two features (extrep unigram and intrep unigram) identify repeating content words. By applying a negative weight to these features, we can reduce repetition. In particular, if the weight is $-\\infty$ , our method is equivalent to $n$ -gram blocking as described by Kulikov et al. (2018). We observe that repetition control is very important, thus all further control experiments include repetition control.  \n\n# 6.2 Specificity  \n\nLike many sequence-to-sequence models using beam search decoding, our baseline frequently asks generic questions such as What music do you like? and gives dull, unspecific responses, such as I like all kinds of music.  \n\nWe control specificity using Normalized Inverse Document Frequency (NIDF) as a measure of word rareness.4 The Inverse Document Frequency of a word $w$ is $\\mathrm{IDF}(w)\\;=\\;\\log(R/c_{w})$ where $R$ is the number of responses in the dataset, and $c_{w}$ is the number of those responses that contain $w$ .Normalized IDF (which ranges from 0 to 1) is  \n\n$$\n\\mathrm{NIDF}(w)=\\frac{\\mathrm{IDF}(w)-\\mathrm{min.idf}}{\\mathrm{max.idf}-\\mathrm{min.idf}}\n$$  \n\nwhere min idf and max idf are the minimum and maximum IDFs, taken over all words in the vocabulary. To control specificity with weighted decoding, we use NIDF as a decoding feature. As shown in Table 1, this method produces reasonable outputs when the feature weight is within a certain range, but at the extremes the outputs are Table 1: Middle: Example of controlling specificity (NIDF) via weighted decoding. At the extremes, the model produces only the most rare or the most common tokens. Bottom: Example of controlling specificity via conditional training. This gives a narrower NIDF range, but all the responses are appropriate.  \n\n![](images/image_2.jpg)  \n\nnonsensical. The boundary for nonsensical output differs from example to example.  \n\nTo control specificity with conditional training, we define the specificity of an utterance $y$ to be the mean NIDF of the words in $y$ . Thus our control variable $z$ is mean NIDF (discretized into 10 equal-sized buckets). As shown in Table 1, this method gives outputs with a narrower NIDF range, but overall produces less nonsensical outputs.  \n\n# 6.3 Response-relatedness  \n\nIn conversation, it’s generally desirable to produce a response that is related to the partner’s last utterance; for example if the partner says My grandfather died last month, it is appropriate to say I’m so sorry. Were you close to your grandfather? However, our baseline model frequently responds with unrelated utterances like Do you have any pets?  \n\nTo control response-relatedness with weighted decoding, we use the decoding feature resp rel:  \n\n$$\n\\begin{array}{r l}&{\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt",
    "chunk_order_index": 3,
    "full_doc_id": "doc-918c69166fc1f4976fcf7ccbb9757946"
  },
  "chunk-cb1496866355af9e7e6b4ccb451766fd": {
    "tokens": 1200,
    "content": "\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt\\tt \n$$  \n\nwhere word emb $(w)$ is the GloVe embedding for the word $w$ , sent emb $(\\ell)$ is the sentence embedding for the partner’s last utterance $\\ell$ (note $\\ell$ is part of the context $x$ ), and cos sim is the cosine similarity between the two. In particular, the sentence embedding sent emb $\\left(s\\right)$ for an utterance $s$ is a weighted average of the GloVe embeddings of the words in $s$ , with the first principal component projected out; for full details, see Arora et al. (2017). This method of controlling response-relatedness is similar to that described in (Baheti et al., 2018). We find that weighted decoding is effective to control the semantic relatedness of the model’s response to the partner’s last utterance (see Table 2). As before, we find that extreme weights lead to nonsensical output.  \n\n![](images/image_3.jpg)  \nTable 2: Example of controlling response-relatedness (cosine similarity to input) via weighted decoding. Positive weights (e.g. 5.0) can yield more on-topic responses, but higher weights (e.g. 11.0) can result in nonsensical lists of topically related words.  \n\nTo control response-relatedness with conditional training, we try defining the control variable $z$ to be $\\mathtt{c o s\\_s i m}(\\mathtt{s e n t\\_e m b}(y),\\mathtt{s e n t}$ emb(ℓ)), the overall cosine similarity between the partner’s last utterance $\\ell$ and the model’s response $y$",
    "chunk_order_index": 4,
    "full_doc_id": "doc-918c69166fc1f4976fcf7ccbb9757946"
  },
  "chunk-2db2df383f9e0dcc2bfa014fdfd468b1": {
    "tokens": 1200,
    "content": ".0) can result in nonsensical lists of topically related words.  \n\nTo control response-relatedness with conditional training, we try defining the control variable $z$ to be $\\mathtt{c o s\\_s i m}(\\mathtt{s e n t\\_e m b}(y),\\mathtt{s e n t}$ emb(ℓ)), the overall cosine similarity between the partner’s last utterance $\\ell$ and the model’s response $y$ (again, we discretize $z$ ). However, we find this method ineffective – the CT model learns only a very weak connection between $z$ and the semantic relatedness of the output (see Section 7 for more details).  \n\n# 6.4 Question-asking  \n\nConsiderate chitchat requires a reciprocal asking and answering of questions – asking too few or too many can appear self-centered or nosy. We control question-asking in order to study these trade-offs.  \n\nTo control question-asking with weighted decoding, we use the binary decoding feature is qn word $(w)$ , which is equal to 1 if and only if the word $w$ is in a pre-defined list of interrogative words (how, what, when, where, which, who, whom, whose, why, ?). We find this is a somewhat effective method to encourage or discourage questions, but with unintended side-effects: a negative weight can discourage valid non-question utterances that happen to contain interrogative words (such as I’m learning how to knit) and a positive weight can result in degenerate utterances (such as  \n\n![](images/image_4.jpg)  \nFigure 2: Controlling question-asking via conditional training. Exact numbers can be found in Appendix F.  \n\n# What??????? or Who? When? How?).  \n\nFor conditional training, we regard an utterance $y$ as containing a question if and only if $y$ contains a question mark. We train our CT model on a control variable $z$ with 11 possible values: $\\{0,\\ldots,10\\}$ . As discussed in Section 5, we wish to control question-asking at the distributional, dialogue level, rather than at the binary, utterance level. Thus the setting $z=i$ means that the model should produce, on average, utterances containing ‘?’ with probability $i/10$ . During training we randomly assign examples to buckets such that each bucket $i$ is trained on examples with the correct proportion of questions $(i/10)$ , and all buckets have the same amount of training examples.  \n\nWe find that conditional training is effective to control question-asking – as shown in Figure 2, by increasing $z$ from 0 to 10, we obtain a range of question-asking rates from $1.40\\%$ to $97.72\\%$ .However, when we introduce repetition control, question-asking is reduced – in particular, the $z=$ 10 setting (which should produce $100\\%$ questions) now only produces $79.67\\%$ questions. The primary problem is the weighted decoding feature extrep bigram, which discourages bigrams that have appeared in previous utterances – this prevents the model from producing bigrams that commonly occur in many questions, such as do you and what is. To fix this, we introduce an extra setting $z\\;=\\;10\\;(b o o s t),$ , in which we do not use the feature extrep bigram for weighted decoding during beam search, but we do use it to rerank the candidates after beam search. This setting, which allows the model to produce necessary questionasking bigrams, yields a $99.54\\%$ question-asking rate, at the cost of slightly increased external bigram repetition (see Appendix F).  \n\nFor controlling question-asking, conditional training is preferable to weighted decoding for two reasons. Firstly, it allows us to achieve (close to) $0\\%$ questions, $100\\%$ questions, or anything in between, without introducing the risk of degenerate output. Secondly, presence-of-a-question-mark captures the true attribute of interest (questionasking) more exactly and directly than presence of interrogative words. For these reasons, only the CT method is considered in the human evaluation.  \n\n# 7 Comparison of control methods  \n\nThe previous section shows that conditional training and weighted decoding are both useful techniques, with different strengths and weaknesses.  \n\nThe primary disadvantage of conditional training is that it sometimes fails to learn the connection between the control variable $z$ and the target output $y$ . In practice, we find the model can learn simple attributes of the output (such as the presence of ‘?’, and overall genericness), but not relationships between the input and output (such as semantic relatedness). By contrast, weighted decoding can force the desired feature to appear in the output by raising the weight arbitrarily high (though this may have unintended side-effects).  \n\nThe primary disadvantage of weighted decoding is that it risks going off-distribution when the weight is too strong. By contrast, conditional training produces mostly well-formed, indistribution outputs. This highlights the importance of learned control – it is safer to learn to produce output that both satisfies the control variable and is appropriate, than to alter the decoding process to satisfy the control variable, potentially trading off appropriateness in the process.  \n\nOther considerations include: (1) Convenience: conditional training requires retraining; weighted decoding doesn’t, but is slower at test time. (2) Data availability: conditional training requires training examples of the controllable attribute, whereas weighted decoding can control any computable feature without requiring examples. (3) Attribute definition: conditional training can control sentence-level attributes, but they must be discrete. By contrast, weighted decoding requires",
    "chunk_order_index": 5,
    "full_doc_id": "doc-918c69166fc1f4976fcf7ccbb9757946"
  },
  "chunk-44f4fb5bff825e761bf2d6022ff9e493": {
    "tokens": 1200,
    "content": "process to satisfy the control variable, potentially trading off appropriateness in the process.  \n\nOther considerations include: (1) Convenience: conditional training requires retraining; weighted decoding doesn’t, but is slower at test time. (2) Data availability: conditional training requires training examples of the controllable attribute, whereas weighted decoding can control any computable feature without requiring examples. (3) Attribute definition: conditional training can control sentence-level attributes, but they must be discrete. By contrast, weighted decoding requires word-level features, but they can be continuous.  \n\n# 8 Human evaluation results  \n\nIn order to study the effect of our controllable attributes, we conduct a large-scale human evaluation of 28 model configurations (see Appendix E), plus human-human conversations for comparison.  \n\nApproach In our evaluation, a crowdworker chats with a model (or in the human-human case, another crowdworker) for six conversational turns, then answers eight multiple-choice questions which each capture different aspects of conversational quality: avoiding repetition, interestingness, making sense, fluency, listening, inquisitiveness, humanness and engagingness. The eight questions are Likert questions on a 1-4 scale, where higher is better. To match the ConvAI2 Challenge, we also add a persona retrieval question, in which the crowdworker is asked to select which of two possible personas was the model’s persona. For full details of the evaluation design, see Appendix B.  \n\nOur evaluation is the same as the ConvAI2 Challenge evaluation, but more detailed – ConvAI2 includes only engagingness and persona retrieval.6 As in the ConvAI2 challenge, each of our 28 model configurations was evaluated by over 100 crowdworkers, and the results were adjusted for annotator variance via a Bayesian calibration (Kulikov et al., 2018).  \n\nIn designing our evaluation, we aimed to capture the four aspects we expected to directly improve via control (avoiding repetition, interestingness, listening, inquisitiveness), two important error classes we thought would be affected by our controls (fluency, making sense), and two overall quality measures (engagingness, humanness).  \n\n# 8.1 Main findings  \n\nIn this section we summarize the main findings of our human evaluation – whose full results can be found in Appendices G and H, with sample conversations in Appendix C.  \n\nAs Figure 3 shows, controlling for repetition, specificity and question-asking all lead to large engagingness improvements over the greedy and beam-search baseline models. In particular, we find that controlling for multi-turn (self) repetition is important and should be incorporated alongside other attribute control methods. We found no improvement by controlling response-relatedness.  \n\nTo better understand these overall engagingness improvements, we consider the full set of human judgments, shown in Figure 4. We find that reducing repetition leads to improvements across all our aspects of conversational quality. Increasing specificity shows improvements in interestingness and listening ability over the repetition-controlled baseline, while increasing question-asking shows improvements in inquisitiveness and interestingness over the repetition-controlled baseline.  \n\nOur most engaging model, which controls both repetition and question-asking – marked ‘Question (CT)’ in Figure 3 (left) – matches the engagingness of the winning entry in the ConvAI2 competition, as both models achieve a raw score of 3.1 (Dinan et al., 2019). However, the ConvAI2 winner, Lost in Conversation, was trained on approximately $12\\times$ as much data as our model. Lost in Conversation is based on the OpenAI GPT Language Model (Radford et al., 2018), which is pretrained on the BookCorpus (Zhu et al., 2015), which contains approximately 985 million words, whereas our model is pretrained on the Twitter dataset (approximately 79 million words).  \n\nAltogether, our evaluation clearly shows that controlling low-level attributes over multiple turns leads to improved overall quality.  \n\n# 8.2 Effect of controlled attributes  \n\nRepetition (WD) We observe that selfrepetition across utterances (external repetition) is by far the most severe form of repetition in our beam search baseline model. We evaluate several settings of the extrep bigram weighted decoding feature, and find that an aggressive repetition-reduction setting (reducing bigram repetition rate to below gold data levels) is rated best. We also find that blocking repeated content words improves the avoiding repetition score. See Appendices E, F and G for full details.  \n\nAs shown in Figure 3 (left) and Figure 4, our repetition-controlled model improves hugely over the beam search baseline in all metrics, and achieves close-to-human scores on all metrics except humanness. This striking result demonstrates that repetition is by far the biggest limiting quality factor for naive sequence-to-sequence dialogue agents. The result also emphasizes the importance of multi-turn dialogue evaluation to detect the problem. We refer to this model as the repetitioncontrolled baseline, and use it as a basis for all remaining experiments (i.e., we control specificity, response-relatedness and question-asking on top of these repetition-control settings).  \n\n![](images/image_5.jpg)  \nFigure 3: Calibrated human judgments of engagingness for the baselines and best controlled models (left); for different specificity control settings (middle); and for different question-asking control settings (right).  \n\n![](images/image_6.jpg)  \nFigure 4: Calibrated human judgments of conversational aspects for the baselines and best controlled models. Note: In Figure 3 and here, the Specificity and Question controlled models both include Repetition control, but Question control doesn’t include Specificity control, or vice versa.  \n\nSpecificity (WD, CT) For our weighted decoding models, the extreme settings (very generic and very specific) score poorly in engagingness due to the frequent presence of degenerate output –",
    "chunk_order_index": 6,
    "full_doc_id": "doc-918c69166fc1f4976fcf7ccbb9757946"
  },
  "chunk-52f18fc482be6f297ab38f40ffc0749a": {
    "tokens": 1200,
    "content": "6.jpg)  \nFigure 4: Calibrated human judgments of conversational aspects for the baselines and best controlled models. Note: In Figure 3 and here, the Specificity and Question controlled models both include Repetition control, but Question control doesn’t include Specificity control, or vice versa.  \n\nSpecificity (WD, CT) For our weighted decoding models, the extreme settings (very generic and very specific) score poorly in engagingness due to the frequent presence of degenerate output – see Figure 3 (middle). We find that the weight $=\\,4$ setting (which is more specific than the repetitioncontrolled baseline and about as specific as the gold data) maximizes engagingness. As shown in Figure 3 (left) and Figure 4, this more-specific model is rated more interesting, engaging, and a better listener than the repetition-controlled baseline, but at the cost of reduced fluency and making sense. Our CT model with $z\\,=\\,7$ (which has a similar NIDF level as WD with weight $=4$ ) shows similar results, but the improvements are smaller. For further discussion on the interestingness of our specificity models, see Section 8.3.  \n\nResponse-relatedness (WD) We evaluated several control settings $(\\mathrm{weight}=-10,5,10,13)$ and found that none scored better than weight $\\mathit{\\Theta}=\\mathit{\\Theta}0$ (no response-relatedness control); see Appendix H. This is surprising – prior to running the human evaluation, we annotated 100 examples ourselves to determine the best control settings. While we identified a more responsive setting (weight $=5$ )as less likely than the uncontrolled model to ignore the user, crowdworkers rated it as a slightly worse listener than the uncontrolled model. One explanation for this discrepancy is that the more responsive model takes more risks, using more rare words (0.197 NIDF, up from 0.178), and thus receives a lower makes-sense score (3.41, down from 3.70). We hypothesize that, compared to us, the crowdworkers are less tolerant of slightly nonsensical output, and more tolerant of generic unrelated utterances.  \n\nQuestion-asking (CT) As shown in Figure 3 (right), a question-asking rate of $65.7\\%$ $(z\\,=\\,7)$ maximizes engagingness. This setting, which asks more questions than both the repetition-controlled baseline $(50.0\\%)$ and the human-produced gold data $(28.8\\%)$ , brings us closest to human-level engagingness – see Figure 3 (left). Although we find that a rate of approximately $65.7\\%$ questionasking is the most engaging, a lower level $(48.9\\%$ ,or $z=4$ ) is rated the best listener. Lastly, we find that although asking too many questions is less engaging, most crowdworkers will not directly criticize a chatbot that asks questions on every turn – only $11.9\\%$ of crowdworkers judged the $z\\,=\\,10$ (boost) setting, which asks $99.5\\%$ questions, as asking too many questions. For full details of these scores, see Appendix F and H.  \n\n![](images/image_7.jpg)  \nTable $3\\colon\\mathrm{A}/\\mathrm{B}$ tests comparing various specificity-controlled models to the repetition-controlled baseline on interestingness. We find all comparisons are significant ( $p<.05$ ; binomial test).  \n\nFor time and budget reasons, we did not evaluate any models controlling both question-asking and specificity. However, we expect it is possible to obtain further improvements by doing so.  \n\n# 8.3 A/B tests for interestingness  \n\nThough our more-specific models yielded signifi- cant improvements in engagingness, we were surprised that they did not yield clearer improvements in interestingness. To investigate further, we conducted an A/B interestingness evaluation of three specificity-controlled models, compared to the repetition-controlled baseline. Crowdworkers were shown two conversations (from the main human evaluation) and asked to choose which model was more interesting (see Figure 7 for details). We collected 500 samples per comparison, plus 200 additional human vs repetition-controlled baseline samples, which were used to filter for quality control. After discarding low-quality crowdworkers, we have roughly 300 evaluations per comparison, with an average Cohen’s $\\kappa=0.6$ .  \n\nAs shown in Table 3, all three models were rated significantly more interesting than the repetitioncontrolled baseline. This convincingly shows that producing utterances with more rare words is a valid strategy to improve interestingness. We have two explanations for why these interestingness differences did not materialize in our main evaluation. Firstly, interestingness is a particularly subjective metric (unlike more tangible metrics such as avoiding repetition and making sense) – this makes it hard to calibrate across crowdworkers.  \n\nSecondly, we suspect that in our original evaluation, the crowdworkers may have evaluated the interestingness of the task rather than the chatbot. This could account for why subtle increases in conversational ability did not result in higher interestingness ratings – the PersonaChat task itself has a natural interestingness limit.  \n\n# 9 Conclusion  \n\nWhat makes a good conversation? Through our evaluation, we showed that a good conversation is about balance – controlling for the right level of repetition, specificity and question-asking is important for overall quality. We also found that conversational aspects such as interestingness, listening, and inquisitiveness are all important – though optimizing these can introduce a trade-off against certain types of errors (such as repetitive, disfluent, or nonsensical output). Secondly, multiturn evaluation is essential to study what makes a good conversation – multiple turns are required to reveal",
    "chunk_order_index": 7,
    "full_doc_id": "doc-918c69166fc1f4976fcf7ccbb9757946"
  },
  "chunk-cf711e589066a10a0dcbe740d428a710": {
    "tokens": 1200,
    "content": ", we showed that a good conversation is about balance – controlling for the right level of repetition, specificity and question-asking is important for overall quality. We also found that conversational aspects such as interestingness, listening, and inquisitiveness are all important – though optimizing these can introduce a trade-off against certain types of errors (such as repetitive, disfluent, or nonsensical output). Secondly, multiturn evaluation is essential to study what makes a good conversation – multiple turns are required to reveal issues such as repetition, consistency, and question-asking frequency. Lastly, what do we mean by ‘good’? Although humanness and engagingness are both commonly used as overall quality metrics, the two are very different. While our models achieved close-to-human scores on engagingness, they failed to get close on humanness – showing that a chatbot need not be human-like to be enjoyable. This striking result also demonstrates the importance of measuring more than one quality metric when evaluating dialogue agents.  \n\nOutlook Our work shows that neural generative systems have systemic problems when applied to open-ended dialogue, some of which (e.g. repetition) are only observable in the multi-turn setting. Furthermore, control of low-level attributes offers a practical way to correct these problems, yielding large improvements to overall quality – in our case, comparable to systems trained on much more data. Future work includes optimizing control settings automatically, and building more convincingly human-like chatbots.  \n\n# References  \n\nSanjeev Arora, Yingyu Liang, and Tengyu Ma. 2017. A simple but tough-to-beat baseline for sentence embeddings. In Proceedings of the International Conference on Learning Representations (ICLR).  \n\nAshutosh Baheti, Alan Ritter, Jiwei Li, and Bill Dolan. 2018. Generating more interesting responses in neural conversation models with distributional constraints. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 3970–3980. Association for Computational Linguistics.  \n\nAntoine Bordes, Y-Lan Boureau, and Jason Weston. 2017. Learning end-to-end goal-oriented dialog. In Proceedings of the International Conference on Learning Representations (ICLR).  \n\nEmily Dinan, Varvara Logacheva, Valentin Malykh, Alexander Miller, Kurt Shuster, Jack Urbanek, Douwe Kiela, Arthur Szlam, Iulian Serban, Ryan Lowe, et al. 2019. The second conversational intelligence challenge (convai2). arXiv preprint arXiv:1902.00098.  \n\nEmily Dinan, Stephen Roller, Kurt Shuster, Angela Fan, Michael Auli, and Jason Weston. 2018. Wizard of Wikipedia: Knowledgepowered conversational agents. arXiv preprint arXiv:1811.01241.  \n\nLayla El Asri, Hannes Schulz, Shikhar Sharma, Jeremie Zumer, Justin Harris, Emery Fine, Rahul Mehrotra, and Kaheer Suleman. 2017. Frames: a corpus for adding memory to goal-oriented dialogue systems. In Proceedings of the 18th Annual SIGDIAL Meeting on Discourse and Dialogue, pages 207–219, Saarbru¨cken, Germany. Association for Computational Linguistics.  \n\nAngela Fan, David Grangier, and Michael Auli. 2018. Controllable abstractive summarization. In Proceedings of the 2nd Workshop on Neural Machine Translation and Generation, pages 45–54. Association for Computational Linguistics.  \n\nJessica Ficler and Yoav Goldberg. 2017. Controlling linguistic style aspects in neural language generation. In Proceedings of the Workshop on Stylistic Variation, pages 94–104. Association for Computational Linguistics.  \n\nMarjan Ghazvininejad, Xing Shi, Jay Priyadarshi, and Kevin Knight. 2017. Hafez: an interactive poetry generation system. In Proceedings of ACL 2017, System Demonstrations, pages 43– 48. Association for Computational Linguistics.   \nFenfei Guo, Angeliki Metallinou, Chandra Khatri, Anirudh Raju, Anu Venkatesh, and Ashwin Ram. 2018. Topic-based evaluation for conversational bots. Advances in Neural Information Processing Systems, Conversational AI Workshop.   \nHelen Hastie. 2012. Metrics and evaluation of spoken dialogue systems, pages 131–150. Springer.   \nMatthew Henderson, Blaise Thomson, and Jason D Williams. 2014. The second dialog state tracking challenge. In Proceedings of the $I5t h$ Annual Meeting of the Special Interest Group on Discourse and Dialogue (SIGDIAL), pages 263–272.   \nZhiting Hu, Zichao Yang, Xiaodan Liang, Ruslan Salakhutdinov, and Eric P Xing. 2017. Toward controlled generation of text. In Thirty-fourth International Conference on Machine Learning.   \nYuta Kikuchi, Graham Neubig, Ryohei Sasano, Hiroya Takamura, and Manabu Okumura. 2016. Controlling output length in neural encoderdecoders. In Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing, pages 1328–1338. Association for Computational Linguistics.   \nIlya Kulikov, Alexander H Miller, Kyunghyun Cho, and Jason Weston. 2018. Importance of a search strategy in neural dialogue modelling. arXiv preprint arXiv:1811.00907.   \nJiwei Li, Michel Galley, Chris Brockett, Jianfeng Gao, and Bill Dolan. 2016a. A diversitypromoting objective function for neural conversation models. In Proceedings of the 2016 Conference of the North American Chapter of the Association for Computational",
    "chunk_order_index": 8,
    "full_doc_id": "doc-918c69166fc1f4976fcf7ccbb9757946"
  },
  "chunk-4f8e5b15b7c7f4528fb81d7933740c5c": {
    "tokens": 1200,
    "content": ", Alexander H Miller, Kyunghyun Cho, and Jason Weston. 2018. Importance of a search strategy in neural dialogue modelling. arXiv preprint arXiv:1811.00907.   \nJiwei Li, Michel Galley, Chris Brockett, Jianfeng Gao, and Bill Dolan. 2016a. A diversitypromoting objective function for neural conversation models. In Proceedings of the 2016 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pages 110–119. Association for Computational Linguistics.   \nJiwei Li, Will Monroe, and Dan Jurafsky. 2017a. Learning to decode for future success. arXiv preprint arXiv:1701.06549.   \nJiwei Li, Will Monroe, Alan Ritter, Dan Jurafsky, Michel Galley, and Jianfeng Gao. 2016b. Deep  \n\nreinforcement learning for dialogue generation. In Proceedings of the 2016 Conference on Empirical Methods in Natural Language Process  \n\ning, pages 1192–1202, Austin, Texas. Association for Computational Linguistics.   \nJiwei Li, Will Monroe, Tianlin Shi, Se´bastien Jean, Alan Ritter, and Dan Jurafsky. 2017b. Adversarial learning for neural dialogue genera  \ntion. arXiv preprint arXiv:1701.06547.   \nChia-Wei Liu, Ryan Lowe, Iulian Serban, Mike Noseworthy, Laurent Charlin, and Joelle Pineau. 2016. How not to evaluate your dialogue system: An empirical study of unsupervised evaluation metrics for dialogue response generation. pages 2122–2132.   \nRyan Lowe, Michael Noseworthy, Iulian Vlad Serban, Nicolas Angelard-Gontier, Yoshua Bengio, and Joelle Pineau. 2017. Towards an   \nautomatic turing test: Learning to evaluate dialogue responses. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers),   \npages 1116–1126. Association for Computational Linguistics.   \nRyan Lowe, Nissan Pow, Iulian Serban, and Joelle Pineau. 2015. The Ubuntu dialogue corpus: A large dataset for research in unstructured multiturn dialogue systems. In Proceedings of the 16th Annual Meeting of the Special Interest Group on Discourse and Dialogue, pages 285– 294, Prague, Czech Republic. Association for Computational Linguistics.   \nAlexander Miller, Will Feng, Dhruv Batra, Antoine Bordes, Adam Fisch, Jiasen Lu, Devi Parikh, and Jason Weston. 2017. ParlAI: A dialog research software platform. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing:   \nSystem Demonstrations, pages 79–84, Copenhagen, Denmark. Association for Computational Linguistics.   \nJekaterina Novikova, Ondˇrej Duˇsek, Amanda Cercas Curry, and Verena Rieser. 2017. Why we need new evaluation metrics for nlg. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages 2241–2252.   \nPrasanna Parthasarathi and Joelle Pineau. 2018. Extending neural generative conversational model using external knowledge sources. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing, pages 690–695, Brussels, Belgium. Association for Computational Linguistics.   \nNanyun Peng, Marjan Ghazvininejad, Jonathan May, and Kevin Knight. 2018. Towards controllable story generation. In Proceedings of the First Workshop on Storytelling, pages 43– 49. Association for Computational Linguistics.   \nJeffrey Pennington, Richard Socher, and Christopher Manning. 2014. GloVe: Global vectors for word representation. In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 1532– 1543, Doha, Qatar. Association for Computational Linguistics.   \nAlec Radford, Karthik Narasimhan, Tim Salimans, and Ilya Sutskever. 2018. Improving language understanding by generative pre-training.   \nIulian Vlad Serban, Ryan Lowe, Laurent Charlin, and Joelle Pineau. 2016a. Generative deep neural networks for dialogue: A short review. Advances in Neural Information Processing Systems workshop on Learning Methods for Dialogue.   \nIulian Vlad Serban, Alessandro Sordoni, Yoshua Bengio, Aaron C Courville, and Joelle Pineau. 2016b. Building end-to-end dialogue systems using generative hierarchical neural network models. In AAAI, volume 16, pages 3776–3784.   \nXiaoyu Shen, Hui Su, Yanran Li, Wenjie Li, Shuzi Niu, Yang Zhao, Akiko Aizawa, and Guoping Long. 2017. A conditional variational framework for dialog generation. In Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 2: Short Papers), pages 504–509. Association for Computational Linguistics.   \nAnu Venkatesh, Chandra Khatri, Ashwin Ram, Fenfei Guo, Raefer Gabriel, Ashish Nagar, Rohit Prasad, Ming Cheng, Behnam Hedayatnia, Angeliki Metallinou, et al. 2017. On evaluating and comparing conversational agents. Advances in Neural Information Processing Systems, Conversational AI Workshop.   \nOriol Vinyals and Quoc Le. 2015. A neural conversational",
    "chunk_order_index": 9,
    "full_doc_id": "doc-918c69166fc1f4976fcf7ccbb9757946"
  },
  "chunk-33f0349892df7c41e5fbf4bb581ea98a": {
    "tokens": 1200,
    "content": "Linguistics.   \nAnu Venkatesh, Chandra Khatri, Ashwin Ram, Fenfei Guo, Raefer Gabriel, Ashish Nagar, Rohit Prasad, Ming Cheng, Behnam Hedayatnia, Angeliki Metallinou, et al. 2017. On evaluating and comparing conversational agents. Advances in Neural Information Processing Systems, Conversational AI Workshop.   \nOriol Vinyals and Quoc Le. 2015. A neural conversational model. In Proceedings of the 31st International Conference on Machine Learning, Deep Learning Workshop, Lille, France.  \n\nand movies: Towards story-like visual explanations by watching movies and reading books. In Proceedings of the IEEE international conference on computer vision, pages 19–27.  \n\nMarilyn A. Walker, Diane J. Litman, Candace A. Kamm, and Alicia Abella. 1997. PARADISE: A framework for evaluating spoken dialogue agents. In Proceedings of the 35th Annual Meeting of the Association for Computational Linguistics, pages 271–280, Madrid, Spain. Association for Computational Linguistics. Di Wang, Nebojsa Jojic, Chris Brockett, and Eric Nyberg. 2017. Steering output style and topic in neural response generation. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages 2140– 2150. Association for Computational Linguistics. Tsung-Hsien Wen, David Vandyke, Nikola Mrksˇi´c, Milica Gasic, Lina M. Rojas Barahona, Pei-Hao Su, Stefan Ultes, and Steve Young. 2017. A network-based end-to-end trainable task-oriented dialogue system. In Proceedings of the 15th Conference of the European Chapter of the Association for Computational Linguistics: Volume 1, Long Papers, pages 438–449. Association for Computational Linguistics. Chen Xing, Wei Wu, Yu Wu, Jie Liu, Yalou Huang, Ming Zhou, and Wei-Ying Ma. 2017. Topic aware neural response generation. In AAAI, volume 17, pages 3351–3357. Ruqing Zhang, Jiafeng Guo, Yixing Fan, Yanyan Lan, Jun Xu, and Xueqi Cheng. 2018a. Learning to control the specificity in neural response generation. In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 1108–1117, Melbourne, Australia. Association for Computational Linguistics. Saizheng Zhang, Emily Dinan, Jack Urbanek, Arthur Szlam, Douwe Kiela, and Jason Weston. 2018b. Personalizing dialogue agents: I have a dog, do you have pets too? In Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers), pages 2204–2213, Melbourne, Australia. Association for Computational Linguistics. Ganbin Zhou, Ping Luo, Rongyu Cao, Fen Lin, Bo Chen, and Qing He. 2017. Mechanismaware neural machine for dialogue response generation. In AAAI, pages 3400–3407. Yukun Zhu, Ryan Kiros, Rich Zemel, Ruslan Salakhutdinov, Raquel Urtasun, Antonio Torralba, and Sanja Fidler. 2015. Aligning books  \n\n# Supplementary Material  \n\nA Screenshots of human evaluation interface  \n\n# Task Description  \n\nIn this task, you will chat with another user playing the part of a given character. For example, your given character could be:  \n\nI am a vegetarian. Ilike swimming. My father used to work for Ford. My favorite band is Maroon5. I got a new job last month, which is about advertising design.  \n\nChat with the other user naturally and try to get to know each other, i.e. both ask questions and answer questions of your chat partner while sticking to your given character  \n\nIf you complete the task, you will receive \\$0.90. It may take up to 48 hours to review the HITs, so please allow that much time to pass before payment. After completion, you may be assigned a qualification that prevents you from working on more if you have completed enough of these HITs  \n\nAfter a given number of turns, you may be asked a few questions in order to evaluate your partner.  \n\nIf your partner answers poorly, change topic. Do not linger on their poor response. Instead, mention this during the evaluation section.  \n\nClose Window/Timeout/Return HIT  \n\nOnce the conversation has started, close window/timeout or return HIT during the chat willresult in HIT EXPIRED to you and NO reward paid.  \n\n# Important Notice  \n\n1. Be aware the conversations you have will be made public, so act as you would e.g. on a public social network like Twitter.   \n2. Please do not send long messages: messages cannot exceed 30 words.   \n3. Please do not reference the task or MTurk itself during the conversation, but speak naturally to the other person.   \n4. Please do not send any message that could make others uncomfortable, including any level of discrimination, racism, sexism and offensive religious/politics comments,   \notherwise the submission will be rejected.  \n\nNote: the user you are chating with may be a human or a bot.  \n\n# Figure 5: Screenshot of the Task Description  \n\n![](images/image_8.jpg)  \nFigure 6: Screenshot of the chat UI, talking with the beam search baseline model.  \n\n![](images/image_9.jpg)  \n\nFigure 7: Screenshot of the A/B test UI, comparing a human-human conversation (left) and a Repetition-controlled baseline model (",
    "chunk_order_index": 10,
    "full_doc_id": "doc-918c69166fc1f4976fcf7ccbb9757946"
  },
  "chunk-8254eb704a12c68df90e37de4dd27b96": {
    "tokens": 941,
    "content": "submission will be rejected.  \n\nNote: the user you are chating with may be a human or a bot.  \n\n# Figure 5: Screenshot of the Task Description  \n\n![](images/image_8.jpg)  \nFigure 6: Screenshot of the chat UI, talking with the beam search baseline model.  \n\n![](images/image_9.jpg)  \n\nFigure 7: Screenshot of the A/B test UI, comparing a human-human conversation (left) and a Repetition-controlled baseline model (right).  \n\n# B Human evaluation questionnaire design  \n\nHere are the questions and multiple-choice options used in the human evaluation, in the order presented:  \n\n![](images/image_10.jpg)  \n\n![](images/image_11.jpg)  \nC Example conversations from human evaluation  \n\nFigure 8: Example conversation with (a) Baseline (b) Repetition-controlled baseline (c) Question-controlled CT ${\\bf\\nabla}z=7)$ ), (d) Specificity-controlled WD (weight $=4\\AA$ ).  \n\n![](images/image_12.jpg)  \n\nTable 4: We define five binary features for controlling different types of repetition via weighted decoding (see Section 5.2). Each feature depends on the word $w$ , the partial hypothesis $y_{<t}$ , and the context $x$ (which includes the model’s own persona and the dialogue history). Each of these features is equal to 1 if and only if the condition on the right is true; otherwise 0.  \n\n![](images/image_13.jpg)  \n\nTable 5: Control settings for all configurations that were human-evaluated. ‘wt’ means the weight used for a weighted decoding feature and $\\mathbf{\\dot{\\omega}}_{z}=\\mathbf{\\dot{\\omega}}$ means the setting (i.e. bucket) for the control variable in conditional training.  \n\n\\* In the setting Question-controlled CT 10 (boost), the feature extrep bigram is not used for weighted decoding during beam search, but it is used to rerank the candidates after beam search. See Section 6.4 for details.  \n\n$^{\\ast\\ast}$ Note that the Response-related controlled models additionally introduce repetition controls to block internal bigram repetition and partner bigram repetition. This was necessary to prevent the model from parroting the partner’s last utterance. In Table 8, we find that just adding these extra repetition controls (here called Responserelated controlled WD 0, i.e. increased repetition control but no response-relatedness control) outperforms our canonical Repetition-controlled baseline. However, given that we discovered this later, our specificity and question controlled models are built on top of the canonical Repetition-controlled baseline.  \n\nF Automatic metrics for all configurations   \n\n![](images/image_14.jpg)  \nTable 6: Automatic metrics (computed over validation set) for all model configurations that were human-evaluated.  \n\nG Human evaluation results for all configurations   \n\n![](images/image_15.jpg)  \nTable 7: Raw scores (mean $\\pm$ std.) for all models and human evaluation metrics.  \n\nThe first eight columns are Likert metrics on a 1-4 scale (except Avoiding Repetition, which is a 1-3 scale), where higher is better (except Inquisitiveness, which has an optimal score of 3). The last column, Persona Retrieval, is on a scale from 0 to 1 where higher is better.  \n\nTable 8: Calibrated scores (mean $\\pm$ std.) for all models and human evaluation metrics.   \n\n![](images/image_16.jpg)  \n\nThe first eight columns are Likert metrics on a 1-4 scale (except Avoiding Repetition, which is a 1-3 scale), where higher is better (except Inquisitiveness, which has an optimal score of 3). The last column, Persona Retrieval, is on a scale from 0 to 1 where higher is better.  \n\nThe maximum of each column (excluding Human row) is in bold.  \n\nRows marked with \\* are the six models included in Figure 3 (left) and Figure 4.  \n\n![](images/image_17.jpg)  \nH Plots of human evaluation results for all configurations  \n\nFigure 9: Calibrated human evaluation scores for all models. This is the same data as in Table 8.  \n\nNote: ‘Repetition-controlled baseline+’ in the rightmost column is ‘Response-related controlled WD $\\mathrm{0'}$ in Table 8. See Table 5 for explanation.",
    "chunk_order_index": 11,
    "full_doc_id": "doc-918c69166fc1f4976fcf7ccbb9757946"
  }
}